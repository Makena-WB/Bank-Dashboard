{"version":3,"file":"tokenRefreshLink.js","sourceRoot":"","sources":["../src/tokenRefreshLink.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ApolloLink,\n  Observable,\n  Operation,\n  NextLink,\n  FetchResult,\n  fromPromise,\n} from '@apollo/client/core';\n\nimport { OperationQueuing } from './queuing';\n\nexport { OperationQueuing, QueuedRequest } from './queuing';\n\nexport type FetchAccessToken = (...args: any[]) => Promise<Response>;\nexport type HandleFetch<AccessTokenPayloadType> = (accessTokenPayload: AccessTokenPayloadType, operation: Operation) => void;\nexport type HandleResponse = (operation: Operation, accessTokenField: string) => any;\nexport type HandleError = (err: Error, operation: Operation) => void;\nexport type IsTokenValidOrUndefined = (operation: Operation, ...args: any[]) => Promise<boolean>;\n\n// Used for any Error for data from the server\n// on a request with a Status >= 300\n// response contains no data or errors\ntype ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n// Thrown when server's response is cannot be parsed\ntype ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nconst throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\nconst parseAndCheckResponse = (operation: Operation, accessTokenField: string) => (response: Response) => {\n  return response\n    .text()\n    .then(bodyText => {\n      if (typeof bodyText !== 'string' || !bodyText.length) {\n        // return empty body immediately\n        return bodyText || '';\n      }\n\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        const parseError = err as ServerParseError;\n        parseError.response = response;\n        parseError.statusCode = response.status;\n        parseError.bodyText = bodyText;\n        return Promise.reject(parseError);\n      }\n    })\n    .then(parsedBody => {\n      if (response.status >= 300) {\n        // Network error\n        throwServerError(\n          response,\n          parsedBody,\n          `Response not successful: Received status code ${response.status}`,\n        );\n      }\n      // token can be delivered via apollo query (body.data) or as usual\n      if (\n        !parsedBody.hasOwnProperty(accessTokenField)\n        && (parsedBody.data && !parsedBody.data.hasOwnProperty(accessTokenField))\n        && !parsedBody.hasOwnProperty('errors')\n      ) {\n        // Data error\n        throwServerError(\n          response,\n          parsedBody,\n          `Server response was missing for query '${operation.operationName}'.`,\n        );\n      }\n\n      return parsedBody;\n    });\n};\n\nexport namespace TokenRefreshLink {\n  export interface Options<AccessTokenPayloadType> {\n    /**\n     * This is a name of access token field in response.\n     * In some scenarios we want to pass additional payload with access token,\n     * i.e. new refresh token, so this field could be the object's name.\n     *\n     * Default: \"access_token\".\n     */\n    accessTokenField?: string;\n\n    /**\n     * Indicates the current state of access token expiration. If the token is not yet expired or the user does not require a token (guest), then true should be returned.\n     */\n    isTokenValidOrUndefined: IsTokenValidOrUndefined;\n\n    /**\n     * When the new access token is retrieved, an app might persist it in memory (consider avoiding local storage) for use in subsequent requests.\n     */\n    handleFetch: HandleFetch<AccessTokenPayloadType>;\n\n    /**\n     * Callback which receives a fresh token from Response\n     */\n    fetchAccessToken: FetchAccessToken;\n\n    /**\n     * Optional. Override internal function to manually parse and extract your token from server response\n     */\n    handleResponse?: HandleResponse;\n\n    /**\n     * Token fetch error callback. Allows to run additional actions like logout. Don't forget to handle Error if you are using this option\n     */\n    handleError?: HandleError;\n  }\n}\n\n\nexport class TokenRefreshLink<AccessTokenPayloadType = string> extends ApolloLink {\n  private accessTokenField: string;\n  private isTokenValidOrUndefined: IsTokenValidOrUndefined;\n  private fetchAccessToken: FetchAccessToken;\n  private handleFetch: HandleFetch<AccessTokenPayloadType>;\n  private handleResponse: HandleResponse;\n  private handleError: HandleError;\n  private fetching: boolean;\n  private queue: OperationQueuing;\n\n  constructor(params: TokenRefreshLink.Options<AccessTokenPayloadType>) {\n    super();\n\n    this.accessTokenField = params.accessTokenField || 'access_token';\n    this.isTokenValidOrUndefined = params.isTokenValidOrUndefined;\n    this.fetchAccessToken = params.fetchAccessToken;\n    this.handleFetch = params.handleFetch;\n    this.handleResponse = params.handleResponse || parseAndCheckResponse;\n    this.handleError = typeof params.handleError === 'function'\n      ? params.handleError\n      : err => {\n        console.error(err)\n      };\n\n    this.fetching = false;\n    this.queue = new OperationQueuing();\n  }\n\n  public request(\n    operation: Operation,\n    forward: NextLink,\n  ): Observable<FetchResult> | null {\n    if (typeof forward !== 'function') {\n      throw new Error('[Token Refresh Link]: Token Refresh Link is a non-terminating link and should not be the last in the composed chain');\n    }\n\n    return fromPromise(\n      this.isTokenValidOrUndefined(operation).then((tokenValidOrUndefined) => {\n        // If token does not exist, which could mean that this is a not registered\n        // user request, or if it is not expired -- act as always\n        if (tokenValidOrUndefined) {\n          return forward(operation);\n        } else {\n          if (!this.fetching) {\n            this.fetching = true;\n            this.fetchAccessToken()\n              .then(this.handleResponse(operation, this.accessTokenField))\n              .then((body) => {\n                const token = this.extractToken(body);\n                if (!token) {\n                  throw new Error(\n                    \"[Token Refresh Link]: Unable to retrieve new access token\"\n                  );\n                }\n                return token;\n              })\n              .then((payload) => {\n                this.handleFetch(payload, operation);\n                this.fetching = false;\n                this.queue.consumeQueue();\n              })\n              .catch((error) => {\n                this.handleError(error, operation);\n                this.fetching = false;\n                this.queue.consumeQueue(error);\n              })\n          }\n\n          return this.queue.enqueueRequest({\n            operation,\n            forward,\n          });\n        }\n      })\n    ).flatMap(val => val)\n  }\n\n  /**\n   * An attempt to extract token from body.data. This allows us to use apollo query\n   * for auth token refreshing\n   * @param body {Object} response body\n   * @return {string} access token\n   */\n  private extractToken = (body: any): AccessTokenPayloadType => {\n    if (body.data) {\n      return body.data[this.accessTokenField];\n    }\n    return body[this.accessTokenField];\n  };\n}\n"]}